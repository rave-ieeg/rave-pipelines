---
output: 
  html_document: 
    toc: true
    toc_float: 
      collapsed: true
    toc_depth: 3
    df_print: kable
    theme: spacelab
params:
  plots_to_include: 
    - over_time_by_electrode
    - by_frequency_over_time
    - over_time_by_trial
    - over_time_by_condition
  do_overall_plots: true
  do_individual_plots: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
# require(knitr)
# require(fontawesome)
knitr::opts_chunk$set(echo = FALSE,
                      message = FALSE,
                      warning = NA)

pe_graphics_settings_cache <- dipsaus::rds_map(
  path = file.path('preferences', 'graphics'))
ravepipeline::pipeline_set_preferences(
  "power_explorer.graphics.reset_on_load" = FALSE)

# Load pipeline
pipeline <- ravepipeline::pipeline_from_path(".")
pipeline$clean()
shared_env <- pipeline$shared_env()
settings <- pipeline$get_settings()

# mount inputs to global environment
list2env(settings, envir = globalenv())
list2env(as.list(shared_env), envir = globalenv())

# Evaluate to get the repository and omnibus_results
pipeline$run(c('repository', 'omnibus_results'), 
             return_values = FALSE)

repository <- pipeline$read("repository")
omnibus_data <- pipeline$read("omnibus_results")

# Read from repository
project <- repository$project$name
subject <- repository$subject$subject_code
brain <- ravecore::rave_brain(repository$subject)

# format the univariate statistical results
# this code taken from module_server.R$per_electrode_results_table
mat <- t(omnibus_data$stats)
mat <- cbind('Electrode' = as.numeric(rownames(mat)), mat)
rownames(mat)=NULL

omnibus_statistics_df <- data.frame(mat)
cnames <- colnames(mat)

pcols <- stringr::str_detect(cnames, 'p\\(|p_fdr\\(')
omnibus_statistics_df[pcols] %<>% lapply(function(v)
  as.numeric(round_pval(v)))
```

```{r, handle_params_if_missing, include=FALSE}
# `%||%` is a base R operator since 4.0
plots_to_include <- params$plots_to_include %||% c(
  "over_time_by_electrode",
  "by_frequency_over_time",
  "over_time_by_trial",
  "over_time_by_condition"
)

# Using !isFALSE in case params is missing
do_individual_plots <- !isFALSE(params$do_individual_plots)

do_overall_plots <- !isFALSE(params$do_overall_plots)

custom_toc <- dipsaus::fastqueue2()
```

```{r plotting_functions, include=FALSE}
call_plot_from_name <- function(nm, pipe, pipe_promise) {
  
  if(missing(pipe)) {
    # pipe_promise <- pipe_res[[2]]
    var <- paste0(nm, '_data')
    pipe_promise$await(var)
    dd <- pipe_promise$get_values(var)
  } else {
    
    if(class(pipe)[1] == 'list') {
      dd <- pipe[[paste0(nm, '_data')]]
    } else {
      dd <- pipe$run(paste0(nm, '_data'))
    }
    
  }
  
  po <- pe_graphics_settings_cache$get(paste0(nm, '_plot_options'))
  
  FUN <- match.fun(paste0('plot_', nm))
  
  invisible(FUN(dd, po))
}
```


---
title: "Univariate Power Analysis Report"
date: |
  Project & subject: ``r repository$subject$subject_id`` <br />
  <small><i>
    Generated by  [RAVE](https://rave.wiki) at `r format(Sys.time(), '%a %X, %b %d, %Y')` 
  </i></small>
---


## Baseline and analysis settings

```{r}
baseline_settings <- pipeline$read("baseline_settings")
baseline_settings$window <- paste0(collapse=',', baseline_settings$window[[1]])

knitr::kable(
  caption='Baseline settings', data.frame(baseline_settings)
)

# strip out redundant/uninformative details
clean_settings <- function(ascs) {
  lapply(ascs, function(asc) {
    asc$frequency_dd <- NULL
    asc$subject_code <- NULL
    asc$project_name <- NULL
    
    if(!isTRUE(asc$censor_info$enabled)) {
      asc$censor_info <- NULL
    }
    
    asc$time %<>% paste0(collapse='-')
    asc$frequency %<>% paste0(collapse=':')
    
    asc
  })
}

# details on how electrodes were processed / anatomy 
analysis_settings_clean <- data.table::rbindlist(
  clean_settings(pipeline$read("analysis_settings_clean"))
)

knitr::kable(
  caption = 'Analysis settings',
  analysis_settings_clean
)

# metadata=list(
#   subject = repository$subject$subject_code,
#   project = repository$subject$project_name,
#   baseline_window = paste0(collapse=':', baseline_settings$window[[1]]), 
#   baseline_scope = baseline_settings$scope[[1]],
#   unit = uoa,
#   signal_type = repository$signal_type,
#   reference = subset(repository$reference_table, Electrode %in% electrodes_to_keep),
#   electrodes = subset(repository$electrode_table, Electrode %in% electrodes_to_keep)
# )
```

## Brain viewer

<button class="btn btn-primary btn-xs collapsed" data-toggle="collapse" data-target="#htmlwidget_container" aria-expanded="false"> Show/Hide 3D Viewer </button>  

```{r}
#| layout: l-screen-insert-right
#| fig.align: center
#| fig.width: 10

brain$set_electrode_values(omnibus_statistics_df)

brain$plot(
  control_display = FALSE,
  side_display = FALSE,
  cex = 7 / 8,
  start_zoom = 7 / 8,
  width = '100%',
  height = '600px'
)
```

## Univariate statistics

```{r}
#| layout: l-screen-insert-right

# if we're plotting individual electrodes, include anchor links
if(do_individual_plots) {
  omnibus_statistics_df$Electrode %<>% sapply(function(ee) {
    sprintf('<a href="#%s_stats">%s</a>',ee,ee)
  })
}

dt <- DT::datatable(
  escape = FALSE,
  omnibus_statistics_df, colnames=cnames, rownames = FALSE,
  # extensions = c('FixedColumns', 'FixedHeader', 'Scroller', 'Buttons'),
  extensions = c("Buttons"),
  options=list(
    autoWidth=TRUE, scroller=TRUE, scrollX=TRUE, scrollY=TRUE,
    buttons = list(list(extend = 'copy', text='copy', title = NULL)),
    fixedColumns = list(leftColumns = 1), class='display', escape=FALSE,
    server = FALSE, #order=TRUE,
    # columnDefs = list(
    #   list(width = '50px', targets = "_all")
    # ),
    dom = 'lftp<"small"B>'
  )
)

char = sapply(omnibus_statistics_df, function(x) any(!is.numeric(x)))
to_round <- omnibus_statistics_df[!(pcols|char)] %>% sapply(get_pretty_digits)

for(ur in unique(to_round)) {
  nms <- names(which(to_round == ur))
  dt %<>% DT::formatRound(nms, digits=ur+1)
}

dt

```



`r if(do_overall_plots) "## Across electrodes graphs"`

```{r, eval=do_overall_plots}
#| layout: l-screen-insert-right
#| fig.align: center
#| fig.width: 12
#| results: hide
re <- lapply(plots_to_include, call_plot_from_name, pipe=pipeline)
```


`r if(do_individual_plots) "## Per electrode results"`

```{r prepare_individual_plot_data}
#| results: hide
orig.settings <- pipeline$get_settings()

wanted <- c('Electrode', 'Label', 'FSLabel')
cols_to_keep <- intersect(wanted, colnames(brain$electrodes$raw_table))

if(! 'FSLabel' %in% cols_to_keep) {
  
  if('Area_fs' %in% colnames(brain$electrodes$raw_table)) {
    brain$electrodes$raw_table$FSLabel <- brain$electrodes$raw_table$Area_fs
    cols_to_keep %<>% c('FSLabel')
  }
}

all_els <- dipsaus::parse_svec(orig.settings$analysis_electrodes)
# get only electrodes that are available in the repo
all_els <- all_els[all_els %in% repository$electrode_list]

electrode_details <- subset(brain$electrodes$raw_table,
                            Electrode %in% all_els,
                            select=cols_to_keep)

build_description <- function(df_row) {
  str <- list(
    'header' = '',
    'body' = ''
  )
  
  str$header = sprintf('Contact %s | %s', df_row$Electrode, df_row$Label)
  
  if('FSLabel' %in% names(df_row)) {
    str$body = df_row$FSLabel
  }
  
  return(str)
}

# all the data objects we need
data_needed <- plots_to_include %&% '_data'

pipe_res <- lapply(all_els, function(ee, settings=orig.settings) {
  # print(ee)
  
  settings$omnibus_includes_all_electrodes <- FALSE
  settings$analysis_electrodes <- as.character(ee)
  settings$loaded_electrodes <- as.character(ee)
  
  pipeline$set_settings(.list = settings)
  
  utils::capture.output({
    utils::capture.output({
      res <- pipeline$run(names = data_needed,
                          debug = FALSE,
                          async = FALSE)
    })
  }, type = "message")
  
  res
})
```

```{r per_electrode_results, eval=do_individual_plots}
#| layout: l-screen-insert-right
#| fig.align: center
#| fig.width: 12
#| results: asis

for(ee in seq_along(all_els)) {
  el <- all_els[ee]
  
  # ravepipeline::logger("Working on e: ", el, level='debug')
  # progress$inc(detail = sprintf("Generating graphs for electrode %s", el))
  
  # gsi <- orig.settings
  edesc <- build_description(subset(electrode_details, Electrode == el))
  
  header_id <- sprintf("%s_stats", el)
  header_content <- edesc$header
  custom_toc$add(list(
    id = header_id,
    content = header_content
  ))
  
  print(shiny::tagList(
    shiny::h3(id = header_id, header_content),
    shiny::p(edesc$body)
  ))
  
  
  # gsi$analysis_electrodes <- as.character(ee)
  
  # pipeline$set_settings(.list = gsi)
  # utils::capture.output(pipeline$run(names = data_needed, debug = FALSE))
  
  utils::capture.output({
    brain$plot_electrodes_on_slices(
      el, zoom = 2, electrode_size = 3, title_position='top',
      decoration = function(i, j) {
        graphics::points(0, 0, pch = 21, col = 'orange', cex = 2.25, lwd=2.5)
      }
    )
  })
  
  lapply(plots_to_include, call_plot_from_name, pipe = pipe_res[[ee]])
  
  # cat(sprintf("Back to top [%s](#top)", fa("arrow-up", fill = "steelblue")))
  print(shiny::a(href = "#top", "Back to top ", fontawesome::fa("arrow-up")))
}
```

::: {.hidden}

```{r custom_toc_block, results='asis', echo=FALSE}
# Build custom Table of contents
custom_toc_items <- custom_toc$as_list()
htmltools::div(
  id = "custom-toc",
  htmltools::tags$ul(
    htmltools::tagList(lapply(custom_toc_items, function(item) {
      htmltools::tags$li(
        htmltools::a(
          href = sprintf('#%s', item$id),
          item$content
        )
      )
    }))
  )
)
```

:::


